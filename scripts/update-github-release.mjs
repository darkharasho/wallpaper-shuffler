#!/usr/bin/env node
import fs from "node:fs";
import path from "node:path";

const rootDir = process.cwd();
const packageJsonPath = path.join(rootDir, "package.json");

const loadEnvFile = (filePath) => {
  if (!fs.existsSync(filePath)) return;
  const raw = fs.readFileSync(filePath, "utf8");
  raw.split(/\r?\n/).forEach((line) => {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) return;
    const match = trimmed.match(/^([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.*)$/);
    if (!match) return;
    const key = match[1];
    let value = match[2] ?? "";
    if (
      (value.startsWith("\"") && value.endsWith("\"")) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }
    if (process.env[key] === undefined) {
      process.env[key] = value;
    }
  });
};

const readArgValue = (args, flag) => {
  const index = args.indexOf(flag);
  if (index === -1) return null;
  return args[index + 1] || null;
};

const resolvedConfigValue = (value) => {
  if (typeof value !== "string") return null;
  if (!value.trim()) return null;
  if (/\$\{env\.[^}]+\}/.test(value)) return null;
  return value;
};

const requestJson = async (method, url, token, body) => {
  const response = await fetch(url, {
    method,
    headers: {
      Accept: "application/vnd.github+json",
      Authorization: `Bearer ${token}`,
      "X-GitHub-Api-Version": "2022-11-28"
    },
    body: body ? JSON.stringify(body) : undefined
  });

  if (response.status === 404) {
    return { ok: false, status: 404, data: null };
  }

  const data = await response.json().catch(() => null);
  return { ok: response.ok, status: response.status, data };
};

loadEnvFile(path.join(rootDir, ".env"));

const args = process.argv.slice(2);
const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;
if (!token) {
  console.error("GITHUB_TOKEN (or GH_TOKEN) is not set. Aborting release upload.");
  process.exit(1);
}

const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
const version = String(packageJson?.version || "0.0.0");
const tagName = `v${version}`;
const outputDir = path.join(rootDir, packageJson?.build?.directories?.output || "dist_out");
const publishConfig = packageJson?.build?.publish || {};
const releaseOwner =
  readArgValue(args, "--release-owner") ||
  process.env.GITHUB_RELEASE_OWNER ||
  resolvedConfigValue(publishConfig.owner);
const releaseRepo =
  readArgValue(args, "--release-repo") ||
  process.env.GITHUB_RELEASE_REPO ||
  resolvedConfigValue(publishConfig.repo);

if (!releaseOwner || !releaseRepo) {
  console.error("Missing GitHub release owner/repo. Set GITHUB_RELEASE_OWNER and GITHUB_RELEASE_REPO.");
  process.exit(1);
}

const releaseNotes = [
  `Release ${tagName}`,
  "",
  "Automated build generated by wallpaper-shuffler."
].join("\n");

const baseUrl = `https://api.github.com/repos/${releaseOwner}/${releaseRepo}`;
let releaseResp = await requestJson("GET", `${baseUrl}/releases/tags/${tagName}`, token);

if (releaseResp.status === 404) {
  releaseResp = await requestJson("POST", `${baseUrl}/releases`, token, {
    tag_name: tagName,
    name: tagName,
    body: releaseNotes,
    draft: true,
    prerelease: false
  });
}

if (!releaseResp.ok || !releaseResp.data?.id) {
  console.error(`Failed to create/load release for ${tagName}.`);
  process.exit(1);
}

let releaseData = releaseResp.data;
if (releaseResp.status === 200) {
  const patchResp = await requestJson("PATCH", `${baseUrl}/releases/${releaseData.id}`, token, {
    name: tagName,
    body: releaseNotes,
    draft: true,
    prerelease: false
  });
  if (!patchResp.ok || !patchResp.data?.id) {
    console.error(`Failed to update release ${tagName}.`);
    process.exit(1);
  }
  releaseData = patchResp.data;
}

const uploadUrl = releaseData?.upload_url?.replace("{?name,label}", "");
if (!uploadUrl) {
  console.error("Release upload URL missing. Aborting asset upload.");
  process.exit(1);
}

const acceptedExtensions = new Set([".yml", ".AppImage", ".exe", ".blockmap", ".zip"]);
const files = fs.existsSync(outputDir)
  ? fs.readdirSync(outputDir, { withFileTypes: true })
      .filter((entry) => entry.isFile() && acceptedExtensions.has(path.extname(entry.name)))
      .map((entry) => ({ absPath: path.join(outputDir, entry.name), name: entry.name }))
  : [];

if (files.length === 0) {
  console.error(`No release artifacts found in ${outputDir}. Aborting upload.`);
  process.exit(1);
}

const existingAssets = Array.isArray(releaseData?.assets) ? releaseData.assets : [];
for (const file of files) {
  const existing = existingAssets.find((asset) => asset?.name === file.name);
  if (existing?.id) {
    await requestJson("DELETE", `${baseUrl}/releases/assets/${existing.id}`, token);
  }

  const uploadResponse = await fetch(`${uploadUrl}?name=${encodeURIComponent(file.name)}`, {
    method: "POST",
    headers: {
      Accept: "application/vnd.github+json",
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/octet-stream",
      "X-GitHub-Api-Version": "2022-11-28"
    },
    body: fs.readFileSync(file.absPath)
  });

  if (!uploadResponse.ok) {
    console.error(`Failed to upload ${file.name} (${uploadResponse.status}).`);
    process.exit(1);
  }
}

const publishResp = await requestJson("PATCH", `${baseUrl}/releases/${releaseData.id}`, token, {
  draft: false,
  body: releaseNotes
});

if (!publishResp.ok) {
  console.error(`Failed to publish release ${tagName}.`);
  process.exit(1);
}

console.log(`Published GitHub release ${tagName} with ${files.length} assets.`);
